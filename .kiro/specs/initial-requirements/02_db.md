# Phase 2: Data Models & Basic CRUD

## Objective
Create the core data models (Stacks, Cards, Elements) with database schema, TypeScript types, and CRUD operations.

## Tasks

### 2.1 Database Schema Extension

**Create Migration**: `supabase/migrations/00002_stacks_and_cards.sql`

```sql
-- Stacks table
CREATE TABLE stacks (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  is_public BOOLEAN DEFAULT false,
  published_at TIMESTAMP WITH TIME ZONE,
  settings JSONB DEFAULT '{
    "theme": "classic",
    "defaultCardId": null,
    "allowComments": false
  }'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Cards table
CREATE TABLE cards (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  stack_id UUID REFERENCES stacks(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL DEFAULT 'Untitled Card',
  order_index INTEGER NOT NULL DEFAULT 0,
  background_color TEXT DEFAULT '#FFFFFF',
  background_image TEXT,
  script TEXT, -- onLoad event script
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Elements table
CREATE TABLE elements (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  card_id UUID REFERENCES cards(id) ON DELETE CASCADE NOT NULL,
  type TEXT NOT NULL, -- 'button', 'text', 'image', 'input', 'shape'
  order_index INTEGER NOT NULL DEFAULT 0,
  position JSONB NOT NULL DEFAULT '{
    "x": 0,
    "y": 0,
    "width": 100,
    "height": 40
  }'::jsonb,
  properties JSONB NOT NULL DEFAULT '{}'::jsonb, -- style, content, etc.
  script TEXT, -- onClick, onChange event script
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Assets table
CREATE TABLE assets (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  stack_id UUID REFERENCES stacks(id) ON DELETE CASCADE NOT NULL,
  type TEXT NOT NULL, -- 'image', 'audio', 'video'
  filename TEXT NOT NULL,
  url TEXT NOT NULL,
  size INTEGER,
  mime_type TEXT,
  uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_stacks_owner ON stacks(owner_id);
CREATE INDEX idx_stacks_public ON stacks(is_public) WHERE is_public = true;
CREATE INDEX idx_cards_stack ON cards(stack_id);
CREATE INDEX idx_cards_order ON cards(stack_id, order_index);
CREATE INDEX idx_elements_card ON elements(card_id);
CREATE INDEX idx_elements_order ON elements(card_id, order_index);
CREATE INDEX idx_assets_stack ON assets(stack_id);

-- Enable RLS
ALTER TABLE stacks ENABLE ROW LEVEL SECURITY;
ALTER TABLE cards ENABLE ROW LEVEL SECURITY;
ALTER TABLE elements ENABLE ROW LEVEL SECURITY;
ALTER TABLE assets ENABLE ROW LEVEL SECURITY;

-- RLS Policies for stacks
CREATE POLICY "Users can view own stacks"
  ON stacks FOR SELECT
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can view public stacks"
  ON stacks FOR SELECT
  USING (is_public = true);

CREATE POLICY "Users can create own stacks"
  ON stacks FOR INSERT
  WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update own stacks"
  ON stacks FOR UPDATE
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can delete own stacks"
  ON stacks FOR DELETE
  USING (auth.uid() = owner_id);

-- RLS Policies for cards
CREATE POLICY "Users can view cards in accessible stacks"
  ON cards FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = cards.stack_id
      AND (stacks.owner_id = auth.uid() OR stacks.is_public = true)
    )
  );

CREATE POLICY "Users can create cards in own stacks"
  ON cards FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = cards.stack_id
      AND stacks.owner_id = auth.uid()
    )
  );

CREATE POLICY "Users can update cards in own stacks"
  ON cards FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = cards.stack_id
      AND stacks.owner_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete cards in own stacks"
  ON cards FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = cards.stack_id
      AND stacks.owner_id = auth.uid()
    )
  );

-- RLS Policies for elements (similar pattern to cards)
CREATE POLICY "Users can view elements in accessible cards"
  ON elements FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM cards
      JOIN stacks ON stacks.id = cards.stack_id
      WHERE cards.id = elements.card_id
      AND (stacks.owner_id = auth.uid() OR stacks.is_public = true)
    )
  );

CREATE POLICY "Users can manage elements in own stacks"
  ON elements FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM cards
      JOIN stacks ON stacks.id = cards.stack_id
      WHERE cards.id = elements.card_id
      AND stacks.owner_id = auth.uid()
    )
  );

-- RLS Policies for assets
CREATE POLICY "Users can view assets in accessible stacks"
  ON assets FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = assets.stack_id
      AND (stacks.owner_id = auth.uid() OR stacks.is_public = true)
    )
  );

CREATE POLICY "Users can manage assets in own stacks"
  ON assets FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM stacks
      WHERE stacks.id = assets.stack_id
      AND stacks.owner_id = auth.uid()
    )
  );

-- Triggers for updated_at
CREATE TRIGGER update_stacks_updated_at
  BEFORE UPDATE ON stacks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_cards_updated_at
  BEFORE UPDATE ON cards
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_elements_updated_at
  BEFORE UPDATE ON elements
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Function to reorder cards when one is deleted
CREATE OR REPLACE FUNCTION reorder_cards_on_delete()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE cards
  SET order_index = order_index - 1
  WHERE stack_id = OLD.stack_id
  AND order_index > OLD.order_index;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER reorder_cards_after_delete
  AFTER DELETE ON cards
  FOR EACH ROW
  EXECUTE FUNCTION reorder_cards_on_delete();

-- Similar function for elements
CREATE OR REPLACE FUNCTION reorder_elements_on_delete()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE elements
  SET order_index = order_index - 1
  WHERE card_id = OLD.card_id
  AND order_index > OLD.order_index;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER reorder_elements_after_delete
  AFTER DELETE ON elements
  FOR EACH ROW
  EXECUTE FUNCTION reorder_elements_on_delete();
```

### 2.2 TypeScript Types

**Update `lib/types/index.ts`**:

```typescript
// Existing User types...

// Stack types
export interface Stack {
  id: string
  ownerId: string
  name: string
  description: string | null
  isPublic: boolean
  publishedAt: string | null
  settings: StackSettings
  createdAt: string
  updatedAt: string
}

export interface StackSettings {
  theme: 'classic' | 'dark' | 'light'
  defaultCardId: string | null
  allowComments: boolean
}

export interface CreateStackInput {
  name: string
  description?: string
}

export interface UpdateStackInput {
  name?: string
  description?: string
  isPublic?: boolean
  settings?: Partial<StackSettings>
}

// Card types
export interface Card {
  id: string
  stackId: string
  name: string
  orderIndex: number
  backgroundColor: string
  backgroundImage: string | null
  script: string | null
  createdAt: string
  updatedAt: string
}

export interface CreateCardInput {
  stackId: string
  name?: string
  backgroundColor?: string
}

export interface UpdateCardInput {
  name?: string
  backgroundColor?: string
  backgroundImage?: string | null
  script?: string | null
}

// Element types
export type ElementType = 'button' | 'text' | 'image' | 'input' | 'shape'

export interface ElementPosition {
  x: number
  y: number
  width: number
  height: number
}

export interface BaseElementProperties {
  fontSize?: number
  fontFamily?: string
  color?: string
  backgroundColor?: string
  borderWidth?: number
  borderColor?: string
  borderRadius?: number
  padding?: number
}

export interface ButtonProperties extends BaseElementProperties {
  label: string
  hoverColor?: string
}

export interface TextProperties extends BaseElementProperties {
  content: string
  align?: 'left' | 'center' | 'right'
  bold?: boolean
  italic?: boolean
}

export interface ImageProperties extends BaseElementProperties {
  src: string
  alt?: string
  objectFit?: 'contain' | 'cover' | 'fill'
}

export interface InputProperties extends BaseElementProperties {
  placeholder?: string
  value?: string
  type?: 'text' | 'number' | 'email'
}

export interface ShapeProperties extends BaseElementProperties {
  shape: 'rectangle' | 'circle' | 'line'
}

export type ElementProperties = 
  | ButtonProperties 
  | TextProperties 
  | ImageProperties 
  | InputProperties 
  | ShapeProperties

export interface Element {
  id: string
  cardId: string
  type: ElementType
  orderIndex: number
  position: ElementPosition
  properties: ElementProperties
  script: string | null
  createdAt: string
  updatedAt: string
}

export interface CreateElementInput {
  cardId: string
  type: ElementType
  position: ElementPosition
  properties: ElementProperties
}

export interface UpdateElementInput {
  position?: ElementPosition
  properties?: Partial<ElementProperties>
  script?: string | null
}

// Asset types
export interface Asset {
  id: string
  stackId: string
  type: 'image' | 'audio' | 'video'
  filename: string
  url: string
  size: number | null
  mimeType: string | null
  uploadedAt: string
}
```

### 2.3 Database Hooks & Services

**Create Stack Service**: `lib/services/stacks.ts`

```typescript
import { createClient } from '@/lib/supabase/client'
import { Stack, CreateStackInput, UpdateStackInput } from '@/lib/types'

export class StackService {
  private supabase = createClient()

  async getMyStacks(): Promise<Stack[]> {
    const { data, error } = await this.supabase
      .from('stacks')
      .select('*')
      .order('updated_at', { ascending: false })

    if (error) throw error
    return this.mapStacks(data)
  }

  async getPublicStacks(): Promise<Stack[]> {
    const { data, error } = await this.supabase
      .from('stacks')
      .select('*')
      .eq('is_public', true)
      .order('updated_at', { ascending: false })

    if (error) throw error
    return this.mapStacks(data)
  }

  async getStack(id: string): Promise<Stack> {
    const { data, error } = await this.supabase
      .from('stacks')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    return this.mapStack(data)
  }

  async createStack(input: CreateStackInput): Promise<Stack> {
    const { data: { user } } = await this.supabase.auth.getUser()
    if (!user) throw new Error('Not authenticated')

    const { data, error } = await this.supabase
      .from('stacks')
      .insert({
        owner_id: user.id,
        name: input.name,
        description: input.description,
      })
      .select()
      .single()

    if (error) throw error
    return this.mapStack(data)
  }

  async updateStack(id: string, input: UpdateStackInput): Promise<Stack> {
    const { data, error } = await this.supabase
      .from('stacks')
      .update({
        name: input.name,
        description: input.description,
        is_public: input.isPublic,
        settings: input.settings,
      })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return this.mapStack(data)
  }

  async deleteStack(id: string): Promise<void> {
    const { error } = await this.supabase
      .from('stacks')
      .delete()
      .eq('id', id)

    if (error) throw error
  }

  private mapStack(data: any): Stack {
    return {
      id: data.id,
      ownerId: data.owner_id,
      name: data.name,
      description: data.description,
      isPublic: data.is_public,
      publishedAt: data.published_at,
      settings: data.settings,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    }
  }

  private mapStacks(data: any[]): Stack[] {
    return data.map(this.mapStack)
  }
}
```

**Create Card Service**: `lib/services/cards.ts`

```typescript
import { createClient } from '@/lib/supabase/client'
import { Card, CreateCardInput, UpdateCardInput } from '@/lib/types'

export class CardService {
  private supabase = createClient()

  async getCards(stackId: string): Promise<Card[]> {
    const { data, error } = await this.supabase
      .from('cards')
      .select('*')
      .eq('stack_id', stackId)
      .order('order_index', { ascending: true })

    if (error) throw error
    return this.mapCards(data)
  }

  async getCard(id: string): Promise<Card> {
    const { data, error } = await this.supabase
      .from('cards')
      .select('*')
      .eq('id', id)
      .single()

    if (error) throw error
    return this.mapCard(data)
  }

  async createCard(input: CreateCardInput): Promise<Card> {
    // Get the max order_index for this stack
    const { data: maxOrderData } = await this.supabase
      .from('cards')
      .select('order_index')
      .eq('stack_id', input.stackId)
      .order('order_index', { ascending: false })
      .limit(1)
      .single()

    const nextOrder = maxOrderData ? maxOrderData.order_index + 1 : 0

    const { data, error } = await this.supabase
      .from('cards')
      .insert({
        stack_id: input.stackId,
        name: input.name || 'Untitled Card',
        background_color: input.backgroundColor || '#FFFFFF',
        order_index: nextOrder,
      })
      .select()
      .single()

    if (error) throw error
    return this.mapCard(data)
  }

  async updateCard(id: string, input: UpdateCardInput): Promise<Card> {
    const { data, error } = await this.supabase
      .from('cards')
      .update({
        name: input.name,
        background_color: input.backgroundColor,
        background_image: input.backgroundImage,
        script: input.script,
      })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return this.mapCard(data)
  }

  async reorderCards(stackId: string, cardIds: string[]): Promise<void> {
    // Update order_index for all cards
    const updates = cardIds.map((id, index) => ({
      id,
      order_index: index,
    }))

    for (const update of updates) {
      await this.supabase
        .from('cards')
        .update({ order_index: update.order_index })
        .eq('id', update.id)
    }
  }

  async deleteCard(id: string): Promise<void> {
    const { error } = await this.supabase
      .from('cards')
      .delete()
      .eq('id', id)

    if (error) throw error
  }

  private mapCard(data: any): Card {
    return {
      id: data.id,
      stackId: data.stack_id,
      name: data.name,
      orderIndex: data.order_index,
      backgroundColor: data.background_color,
      backgroundImage: data.background_image,
      script: data.script,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    }
  }

  private mapCards(data: any[]): Card[] {
    return data.map(this.mapCard)
  }
}
```

**Create Element Service**: `lib/services/elements.ts`

```typescript
import { createClient } from '@/lib/supabase/client'
import { Element, CreateElementInput, UpdateElementInput } from '@/lib/types'

export class ElementService {
  private supabase = createClient()

  async getElements(cardId: string): Promise<Element[]> {
    const { data, error } = await this.supabase
      .from('elements')
      .select('*')
      .eq('card_id', cardId)
      .order('order_index', { ascending: true })

    if (error) throw error
    return this.mapElements(data)
  }

  async createElement(input: CreateElementInput): Promise<Element> {
    // Get the max order_index for this card
    const { data: maxOrderData } = await this.supabase
      .from('elements')
      .select('order_index')
      .eq('card_id', input.cardId)
      .order('order_index', { ascending: false })
      .limit(1)
      .single()

    const nextOrder = maxOrderData ? maxOrderData.order_index + 1 : 0

    const { data, error } = await this.supabase
      .from('elements')
      .insert({
        card_id: input.cardId,
        type: input.type,
        position: input.position,
        properties: input.properties,
        order_index: nextOrder,
      })
      .select()
      .single()

    if (error) throw error
    return this.mapElement(data)
  }

  async updateElement(id: string, input: UpdateElementInput): Promise<Element> {
    const updateData: any = {}
    if (input.position) updateData.position = input.position
    if (input.properties) updateData.properties = input.properties
    if (input.script !== undefined) updateData.script = input.script

    const { data, error } = await this.supabase
      .from('elements')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return this.mapElement(data)
  }

  async deleteElement(id: string): Promise<void> {
    const { error } = await this.supabase
      .from('elements')
      .delete()
      .eq('id', id)

    if (error) throw error
  }

  private mapElement(data: any): Element {
    return {
      id: data.id,
      cardId: data.card_id,
      type: data.type,
      orderIndex: data.order_index,
      position: data.position,
      properties: data.properties,
      script: data.script,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
    }
  }

  private mapElements(data: any[]): Element[] {
    return data.map(this.mapElement)
  }
}
```

### 2.4 Custom React Hooks

**Stack Hooks**: `lib/hooks/useStacks.ts`

```typescript
'use client'

import { useState, useEffect } from 'react'
import { StackService } from '@/lib/services/stacks'
import { Stack, CreateStackInput, UpdateStackInput } from '@/lib/types'

export function useStacks() {
  const [stacks, setStacks] = useState<Stack[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const stackService = new StackService()

  useEffect(() => {
    loadStacks()
  }, [])

  const loadStacks = async () => {
    try {
      setLoading(true)
      const data = await stackService.getMyStacks()
      setStacks(data)
      setError(null)
    } catch (err: any) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }

  const createStack = async (input: CreateStackInput) => {
    try {
      const newStack = await stackService.createStack(input)
      setStacks([newStack, ...stacks])
      return newStack
    } catch (err: any) {
      setError(err.message)
      throw err
    }
  }

  const updateStack = async (id: string, input: UpdateStackInput) => {
    try {
      const updated = await stackService.updateStack(id, input)
      setStacks(stacks.map(s => s.id === id ? updated : s))
      return updated
    } catch (err: any) {
      setError(err.message)
      throw err
    }
  }

  const deleteStack = async (id: string) => {
    try {
      await stackService.deleteStack(id)
      setStacks(stacks.filter(s => s.id !== id))
    } catch (err: any) {
      setError(err.message)
      throw err
    }
  }

  return {
    stacks,
    loading,
    error,
    createStack,
    updateStack,
    deleteStack,
    refresh: loadStacks,
  }
}

export function useStack(id: string) {
  const [stack, setStack] = useState<Stack | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const stackService = new StackService()

  useEffect(() => {
    loadStack()
  }, [id])

  const loadStack = async () => {
    try {
      setLoading(true)
      const data = await stackService.getStack(id)
      setStack(data)
      setError(null)
    } catch (err: any) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }

  return { stack, loading, error, refresh: loadStack }
}
```

### 2.5 Dashboard Page

**Dashboard**: `app/dashboard/page.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useStacks } from '@/lib/hooks/useStacks'
import { useAuth } from '@/lib/auth/AuthContext'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Plus, LogOut } from 'lucide-react'
import Link from 'next/link'

export default function DashboardPage() {
  const { stacks, loading, createStack, deleteStack } = useStacks()
  const { user, signOut } = useAuth()
  const [showCreateDialog, setShowCreateDialog] = useState(false)
  const [newStackName, setNewStackName] = useState('')
  const [newStackDescription, setNewStackDescription] = useState('')

  const handleCreateStack = async () => {
    try {
      await createStack({
        name: newStackName,
        description: newStackDescription,
      })
      setShowCreateDialog(false)
      setNewStackName('')
      setNewStackDescription('')
    } catch (error) {
      console.error('Failed to create stack:', error)
    }
  }

  if (loading) {
    return <div className="min-h-screen flex items-center justify-center">Loading...</div>
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white border-b-2 border-black">
        <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-2xl font-bold">HyperCard Renaissance</h1>
          <div className="flex items-center gap-4">
            <span className="text-sm text-gray-600">{user?.email}</span>
            <Button onClick={() => signOut()} variant="outline" size="sm">
              <LogOut className="w-4 h-4 mr-2" />
              Sign Out
            </Button>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">My Stacks</h2>
          <Button onClick={() => setShowCreateDialog(true)}>
            <Plus className="w-4 h-4 mr-2" />
            New Stack
          </Button>
        </div>

        {/* Stacks Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {stacks.map((stack) => (
            <Card key={stack.id} className="p-6 border-2 border-black shadow-hypercard hover:shadow-hypercard-hover transition-shadow">
              <Link href={`/editor/${stack.id}`}>
                <h3 className="text-lg font-semibold mb-2">{stack.name}</h3>
                {stack.description && (
                  <p className="text-sm text-gray-600 mb-4">{stack.description}</p>
                )}
                <p className="text-xs text-gray-400">
                  Updated {new Date(stack.updatedAt).toLocaleDateString()}
                </p>
              </Link>
            </Card>
          ))}
        </div>

        {stacks.length === 0 && (
          <div className="text-center py-12">
            <p className="text-gray-500 mb-4">No stacks yet. Create your first one!</p>
            <Button onClick={() => setShowCreateDialog(true)}>
              <Plus className="w-4 h-4 mr-2" />
              Create Stack
            </Button>
          </div>
        )}
      </main>

      {/* Create Stack Dialog */}
      <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Create New Stack</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <Input
              placeholder="Stack Name"
              value={newStackName}
              onChange={(e) => setNewStackName(e.target.value)}
            />
            <Input
              placeholder="Description (optional)"
              value={newStackDescription}
              onChange={(e) => setNewStackDescription(e.target.value)}
            />
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setShowCreateDialog(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateStack} disabled={!newStackName}>
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}
```

## Deliverables Checklist

- [ ] Database schema extended with stacks, cards, elements, assets tables
- [ ] RLS policies implemented for all tables
- [ ] TypeScript types created for all models
- [ ] Service classes for CRUD operations
- [ ] Custom React hooks for data fetching
- [ ] Dashboard page showing user's stacks
- [ ] Create stack functionality
- [ ] Navigation to editor (placeholder for next phase)

## Testing Checklist

- [ ] User can create a new stack
- [ ] Stacks display on dashboard
- [ ] User can only see their own stacks (not other users')
- [ ] Stack CRUD operations work correctly
- [ ] RLS policies prevent unauthorized access
- [ ] Auto-save triggers update `updated_at` timestamps

## Next Phase
Proceed to `03-PHASE-3-EDITOR.md` for building the card editor UI.